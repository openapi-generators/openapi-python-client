import ssl
from typing import Any, Dict, Union, Optional

import httpx

{% if config.use_dataclasses %}
from copy import copy
from dataclasses import dataclass, field, replace
{% set class_header = "" %}
{% else %}
from attrs import define, field, evolve
{% set class_header = "@define" %}
{% endif %}

{% if config.use_dataclasses %}
@dataclass
class _HttpxConfig:
    cookies: Dict[str, str] = field(default_factory=dict)
    headers: Dict[str, str] = field(default_factory=dict)
    timeout: Optional[httpx.Timeout] = None
    verify_ssl: bool = True
    follow_redirects: bool = False
    httpx_args: Dict[str, str] = field(default_factory=dict)
{% endif %}

{% macro httpx_client_arg(name) -%}
{% if config.use_dataclasses %}self._httpx_config.{{ name }}{% else %}self._{{ name }}{% endif %}
{%- endmacro %}

{{ class_header }}
class Client:
    """A class for keeping track of data related to the API

{% macro httpx_args_docstring() %}
    The following are accepted as keyword arguments and will be used to construct httpx Clients internally:

        ``base_url``: The base URL for the API, all requests are made to a relative path to this URL

        ``cookies``: A dictionary of cookies to be sent with every request

        ``headers``: A dictionary of headers to be sent with every request

        ``timeout``: The maximum amount of a time a request can take. API functions will raise
        httpx.TimeoutException if this is exceeded.

        ``verify_ssl``: Whether or not to verify the SSL certificate of the API server. This should be True in production,
        but can be set to False for testing purposes.

        ``follow_redirects``: Whether or not to follow redirects. Default value is False.

        ``httpx_args``: A dictionary of additional arguments to be passed to the ``httpx.Client`` and ``httpx.AsyncClient`` constructor.
{% endmacro %}
{{ httpx_args_docstring() }}

    Attributes:
        raise_on_unexpected_status: Whether or not to raise an errors.UnexpectedStatus if the API returns a
            status code that was not documented in the source OpenAPI document. Can also be provided as a keyword
            argument to the constructor.
    """
{% macro attributes(extra_attrs = []) %}
{% if config.use_dataclasses %}
    _base_url: str
{% for extra in extra_attrs %}
    {{ extra }}
{% endfor %}
    _httpx_config: _HttpxConfig
    _client: Optional[httpx.Client]
    _async_client: Optional[httpx.AsyncClient]
{% else %}
    raise_on_unexpected_status: bool = field(default=False, kw_only=True)
    _base_url: str = field(alias="base_url")
    _cookies: Dict[str, str] = field(factory=dict, kw_only=True, alias="cookies")
    _headers: Dict[str, str] = field(factory=dict, kw_only=True, alias="headers")
    _timeout: Optional[httpx.Timeout] = field(default=None, kw_only=True, alias="timeout")
    _verify_ssl: Union[str, bool, ssl.SSLContext] = field(default=True, kw_only=True, alias="verify_ssl")
    _follow_redirects: bool = field(default=False, kw_only=True, alias="follow_redirects")
    _httpx_args: Dict[str, Any] = field(factory=dict, kw_only=True, alias="httpx_args")
    _client: Optional[httpx.Client] = field(default=None, init=False)
    _async_client: Optional[httpx.AsyncClient] = field(default=None, init=False)

{% if extra_attrs %}
{% for extra in extra_attrs %}
    {{ extra }}
{% endfor %}
{% endif %}
{% endif %}
{% endmacro %}

{{ attributes() }}

{% macro explicit_initializer(extra_attrs = []) %}
    def __init__(
        self,
        base_url: str,
{% for attr in extra_attrs %}
        {{ attr }},
{% endfor %}
        cookies: Dict[str, str] = {},
        headers: Dict[str, str] = {},
        timeout: Optional[httpx.Timeout] = None,
        verify_ssl: bool = True,
        follow_redirects: bool = False,
        httpx_args: Dict[str, Any] = {},
        raise_on_unexpected_status: bool = False,
    ) -> None:
        self.raise_on_unexpected_status = raise_on_unexpected_status
        self._base_url = base_url
        self._httpx_config = _HttpxConfig(
            cookies, headers, timeout, verify_ssl, follow_redirects, httpx_args
        )
        self._client = None
        self._async_client = None
{% endmacro %}

{% if config.use_dataclasses %}
{{ explicit_initializer() }}
{% endif %}

{% macro builders(self) %}
{% if config.use_dataclasses %}
    def _with_httpx_config(self, httpx_config: _HttpxConfig) -> "{{ self }}":
        ret = copy(self)
        ret._httpx_config = httpx_config
        ret._client = None
        ret._async_client = None
        return ret
{% endif %}

    def with_headers(self, headers: Dict[str, str]) -> "{{ self }}":
        """Get a new client matching this one with additional headers"""
        if self._client is not None:
            self._client.headers.update(headers)
        if self._async_client is not None:
            self._async_client.headers.update(headers)
        {% if config.use_dataclasses %}
        return self._with_httpx_config(
            replace(self._httpx_config, headers={**self._httpx_config.headers, **headers}),
        )
        {% else %}
        return evolve(self, headers={**self._headers, **headers})
        {% endif %}

    def with_cookies(self, cookies: Dict[str, str]) -> "{{ self }}":
        """Get a new client matching this one with additional cookies"""
        if self._client is not None:
            self._client.cookies.update(cookies)
        if self._async_client is not None:
            self._async_client.cookies.update(cookies)
        {% if config.use_dataclasses %}
        return self._with_httpx_config(
            replace(self._httpx_config, cookies={**self._httpx_config.cookies, **cookies}),
        )
        {% else %}
        return evolve(self, cookies={**self._cookies, **cookies})
        {% endif %}

    def with_timeout(self, timeout: httpx.Timeout) -> "{{ self }}":
        """Get a new client matching this one with a new timeout (in seconds)"""
        if self._client is not None:
            self._client.timeout = timeout
        if self._async_client is not None:
            self._async_client.timeout = timeout
        {% if config.use_dataclasses %}
        return self._with_httpx_config(replace(self._httpx_config, timeout=timeout))
        {% else %}
        return evolve(self, timeout=timeout)
        {% endif %}
{% endmacro %}

{{ builders("Client") }}

{% macro httpx_stuff(name, headers_expr, update_headers=None) %}
    def set_httpx_client(self, client: httpx.Client) -> "{{ name }}":
        """Manually set the underlying httpx.Client

        **NOTE**: This will override any other settings on the client, including cookies, headers, and timeout.
        """
        self._client = client
        return self

    def get_httpx_client(self) -> httpx.Client:
        """Get the underlying httpx.Client, constructing a new one if not previously set"""
        if self._client is None:
        {% if update_headers %}
            {{ update_headers | indent(12) }}
        {% endif %}
            self._client = httpx.Client(
                base_url=self._base_url,
                cookies={{ httpx_client_arg("cookies") }},
                headers={{ headers_expr }},
                timeout={{ httpx_client_arg("timeout") }},
                verify={{ httpx_client_arg("verify_ssl") }},
                follow_redirects={{ httpx_client_arg("follow_redirects") }},
                **{{ httpx_client_arg("httpx_args") }},
            )
        return self._client

    def __enter__(self) -> "{{ name }}":
        """Enter a context manager for self.client—you cannot enter twice (see httpx docs)"""
        self.get_httpx_client().__enter__()
        return self

    def __exit__(self, *args: Any, **kwargs: Any) -> None:
        """Exit a context manager for internal httpx.Client (see httpx docs)"""
        self.get_httpx_client().__exit__(*args, **kwargs)

    def set_async_httpx_client(self, async_client: httpx.AsyncClient) -> "{{ name }}":
        """Manually the underlying httpx.AsyncClient

        **NOTE**: This will override any other settings on the client, including cookies, headers, and timeout.
        """
        self._async_client = async_client
        return self

    def get_async_httpx_client(self) -> httpx.AsyncClient:
        """Get the underlying httpx.AsyncClient, constructing a new one if not previously set"""
        if self._async_client is None:
        {% if update_headers %}
            {{ update_headers | indent(12) }}
        {% endif %}
            self._async_client = httpx.AsyncClient(
                base_url={{ httpx_client_arg("base_url") }},
                cookies={{ httpx_client_arg("cookies") }},
                headers={{ headers_expr or httpx_client_arg("headers") }},
                timeout={{ httpx_client_arg("timeout") }},
                verify={{ httpx_client_arg("verify_ssl") }},
                follow_redirects={{ httpx_client_arg("follow_redirects") }},
                **{{ httpx_client_arg("httpx_args") }},
            )
        return self._async_client

    async def __aenter__(self) -> "{{ name }}":
        """Enter a context manager for underlying httpx.AsyncClient—you cannot enter twice (see httpx docs)"""
        await self.get_async_httpx_client().__aenter__()
        return self

    async def __aexit__(self, *args: Any, **kwargs: Any) -> None:
        """Exit a context manager for underlying httpx.AsyncClient (see httpx docs)"""
        await self.get_async_httpx_client().__aexit__(*args, **kwargs)
{% endmacro %}

{% if config.use_dataclasses %}
{{ httpx_stuff("Client", headers_expr="self._httpx_config.headers") }}
{% else %}
{{ httpx_stuff("Client", headers_expr="self._headers") }}
{% endif %}

{{ class_header }}
class AuthenticatedClient:
    """A Client which has been authenticated for use on secured endpoints

{{ httpx_args_docstring() }}

    Attributes:
        raise_on_unexpected_status: Whether or not to raise an errors.UnexpectedStatus if the API returns a
            status code that was not documented in the source OpenAPI document. Can also be provided as a keyword
            argument to the constructor.
        token: The token to use for authentication
        prefix: The prefix to use for the Authorization header
        auth_header_name: The name of the Authorization header
    """

{% set extra_auth_client_args = ["token: str", 'prefix: str = "Bearer"', 'auth_header_name: str = "Authorization"'] %}
{{ attributes(extra_auth_client_args) }}

{% if config.use_dataclasses %}
{{ explicit_initializer(extra_auth_client_args) }}
        self.token = token
        self.prefix = prefix
        self.auth_header_name = auth_header_name
{% endif %}

{{ builders("AuthenticatedClient") }}
{% set token_string_expr %} f"{self.prefix} {self.token}" if self.prefix else self.token {% endset %}
{% if config.use_dataclasses %}
{% set headers_expr %} { self.auth_header_name: ({{ token_string_expr }}), **self._httpx_config.headers } {% endset %}
{{ httpx_stuff(
     "AuthenticatedClient",
     headers_expr=headers_expr,
) }}
{% else %}
{% set update_headers %}self._headers[self.auth_header_name] = {{ token_string_expr }}{% endset %}
{{ httpx_stuff(
     "AuthenticatedClient",
     headers_expr="self._headers",
     update_headers=update_headers,
) }}
{% endif %}
